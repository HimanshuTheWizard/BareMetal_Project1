/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*---------TASK CONTROL BLOCK---------*/
typedef struct
{
	uint32_t psp_value;
	uint32_t block_count;
	uint8_t running_state;
	void (*task_handler)(void);
}TCB_t;

/*---------GLOBAL VARIABLES---------*/
uint32_t Current_task = 1;
uint32_t Global_tick_count;
TCB_t User_task_ctl_block[MAX_TASKS_COUNT];

uint32_t *pPSP;
uint16_t j,i;

int main(void)
{
	Enable_Processor_Faults();

	Tasks_Stack_Init();

	Scheduler_Stack_Init(SCHEDULER_STACK_START);

	Switch_SP_to_PSP();

	led_init_all();

	SysTick_Init(TICK_HZ);

	task1_handler();

	/* Loop forever */
	for(;;);
}

/*---------IDLE TASK---------*/
void Idle_task(void)
{
	while(1);
}

void task1_handler(void)
{
	while(1)
	{
		led_on(LED_GREEN);
		task_delay(1000);
		led_off(LED_GREEN);
		task_delay(1000);
	}
}

void task2_handler(void)
{
	while(1)
	{
		led_on(LED_ORANGE);
		task_delay(500);
		led_off(LED_ORANGE);
		task_delay(500);
	}
}
void task3_handler(void)
{
	while(1)
	{
		led_on(LED_RED);
		task_delay(250);
		led_off(LED_RED);
		task_delay(250);
	}
}
void task4_handler(void)
{
	while(1)
	{
		led_on(LED_BLUE);
		task_delay(125);
		led_off(LED_BLUE);
		task_delay(125);
	}
}

void SysTick_Init(uint32_t freq)
{
	uint32_t count_val 	=  (SYSTICK_CLOCK/freq)-1;
	uint32_t *pSTK_LOAD = (uint32_t *)0xE000E014;
	uint32_t *STK_CTRL  = (uint32_t *)0xE000E010;

	*pSTK_LOAD &= ~(0x00FFFFFF);			//Clear the register
	*pSTK_LOAD |= count_val;				//load the value
	*STK_CTRL  |= (1<<2);   				//set systick clock as processor clock
	*STK_CTRL  |= (1<<1);					//enable systick
	*STK_CTRL  |= (1<<0);					//starts the systick counter
}

/*---------Initializing scheduler stack---------*/
__attribute__((naked)) void Scheduler_Stack_Init(uint32_t scheduler_stack_start)
{
	__asm volatile("MSR MSP,%0": :"r" (scheduler_stack_start) : );
	__asm volatile("BX LR");
}


void Tasks_Stack_Init(void)
{
	User_task_ctl_block[0].psp_value = IDLE_STACK_START;
	User_task_ctl_block[1].psp_value = TASK1_STACK_START;
	User_task_ctl_block[2].psp_value = TASK2_STACK_START;
	User_task_ctl_block[3].psp_value = TASK3_STACK_START;
	User_task_ctl_block[4].psp_value = TASK4_STACK_START;

	User_task_ctl_block[0].task_handler = Idle_task;
	User_task_ctl_block[1].task_handler = task1_handler;
	User_task_ctl_block[2].task_handler = task2_handler;
	User_task_ctl_block[3].task_handler = task3_handler;
	User_task_ctl_block[4].task_handler = task4_handler;

	User_task_ctl_block[0].running_state = READY_STATE;
	User_task_ctl_block[1].running_state = READY_STATE;
	User_task_ctl_block[2].running_state = READY_STATE;
	User_task_ctl_block[3].running_state = READY_STATE;
	User_task_ctl_block[4].running_state = READY_STATE;

	for(i=0;i<MAX_TASKS_COUNT;i++)
	{
		pPSP = (uint32_t *)User_task_ctl_block[i].psp_value;
		pPSP--;
		*pPSP = 0x01000000;				//Dummy XPSP
		pPSP--;
		*pPSP = (uint32_t)User_task_ctl_block[i].task_handler;		//Dummy return address
		pPSP--;
		*pPSP = 0xFFFFFFFD;				//Dummy LR

		for(j=0;j<13;j++)				//R0-R3, R12 + R4-R11
		{
			pPSP--;
			*pPSP =	0x00000000;
		}

		User_task_ctl_block[i].psp_value = (uint32_t)pPSP;	//preserv the value of updated PSP
	}
}

void Enable_Processor_Faults(void)
{
	uint32_t *pSHCSR = (uint32_t *)0xE000ED24;
	*pSHCSR |= (1<<16)|(1<<17)|(1<<18);
}

void schedule(void)
{
	Pending_PendSV();
}

void task_delay(uint32_t tick_count)
{
	INTERRUPT_DISABLE();
	if(Current_task)
	{
		User_task_ctl_block[Current_task].block_count = Global_tick_count + tick_count;
		User_task_ctl_block[Current_task].running_state = BLOCKED_STATE;
		schedule();
	}
	INTERRUPT_ENABLE();
}


__attribute__((naked)) void Switch_SP_to_PSP(void)
{
    //1. initialize the PSP with TASK1 stack start address

	//get the value of psp of current_task
	__asm volatile ("PUSH {LR}"); //preserve LR which connects back to main()
	__asm volatile ("BL Get_Current_task_PSP");
	__asm volatile ("MSR PSP,R0"); //initialize psp
	__asm volatile ("POP {LR}");  //pops back LR value

	//2. change SP to PSP using CONTROL register
	__asm volatile ("MOV R0,#0X02");
	__asm volatile ("MSR CONTROL,R0");
	__asm volatile ("BX LR");
}
void update_psp_value(uint32_t current_psp)
{
	User_task_ctl_block[Current_task].psp_value = current_psp;
}

uint32_t Get_Current_task_PSP(void)
{
	return User_task_ctl_block[Current_task].psp_value;
}

void schedule_next_task(void)
{
	uint8_t i = 0;

	for(i = 0; i<MAX_TASKS_COUNT; ++i)
	{
		Current_task++;
		Current_task %= MAX_TASKS_COUNT;
		if((User_task_ctl_block[Current_task].running_state == READY_STATE) && (Current_task != 0))
		{
			break;
		}
	}

	if(User_task_ctl_block[Current_task].running_state != READY_STATE)
	{
		Current_task = 0;
	}
}

__attribute__((naked)) void PendSV_Handler(void)
{
	// Context switching takes place in here
	// Saving context of current task
	// Get PSP of current task
	__asm volatile("MRS R0,PSP");
	// save SF2 registers to stack
	__asm volatile("STMDB R0!,{R4-R11}");
	// saving LR value
	__asm volatile("PUSH {LR}");

	// Update new PSP value
	__asm volatile("BL update_psp_value");

	// Retrieving context of previous task
	// Get next task to run
	__asm volatile("BL schedule_next_task");
	// Get PSP of next task
	__asm volatile("BL Get_Current_task_PSP");
	// load SF2 from memory to registers of corresponding task
	__asm volatile("LDMIA R0!,{R4-R11}");
	// Update PSP
	__asm volatile("MSR PSP,R0");

	// retrieving LR
	__asm volatile("POP {LR}");

	__asm volatile("BX LR");
}

void update_global_tick_count(void)
{
	Global_tick_count++;
}

void Unblocking_task(void)
{
	uint8_t i;
	for(i = 1; i< MAX_TASKS_COUNT; i++)
	{
		if(User_task_ctl_block[i].running_state == BLOCKED_STATE)
		{
			if(User_task_ctl_block[i].block_count == Global_tick_count)
			{
				User_task_ctl_block[i].running_state = READY_STATE;
			}
		}
	}
}

void Pending_PendSV(void)
{
	uint32_t *pICSR = (uint32_t *)0xE000ED04;
	*pICSR |= (1<<28);
}

void SysTick_Handler(void)
{
	update_global_tick_count();
	Unblocking_task();
	Pending_PendSV();
}
void HardFault_Handler(void)
{
	printf("Exception: Hardfault\n");
	while(1);
}
void MemManage_Handler(void)
{
	printf("Exception: MemManagefault\n");
	while(1);
}
void BusFault_Handler(void)
{
	printf("Exception: Busfault\n");
	while(1);
}
